<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>AR Camiseta — con botón foto/record</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <style>
    html,body{margin:0;height:100%;background:#000;color:#fff;font-family:Arial, sans-serif}
    #videoWrapper{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;overflow:hidden}
    video#cam{width:100%;height:100%;object-fit:cover;}
    canvas#overlay{position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none; z-index:20}
    #overlayContainer{position:fixed; left:50%; top:50%; pointer-events:none; z-index:9999; display:none; transform-origin:center center; background:transparent; transform:translate(-50%,-50%);}
    #overlayContainer > video { display:block; width:100%; height:100%; background:transparent; object-fit:cover; }
    #controls{position:fixed; right:12px; top:60px; z-index:10000; display:flex; flex-direction:column; gap:8px}
    .ctrlBtn{padding:10px 12px;border-radius:8px;border:none;background:#ff4fa8;color:#fff;font-weight:600}
    #startBtn{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);padding:14px 18px;background:#ff4fa8;border-radius:10px;border:none;color:#fff;font-size:18px;z-index:40}
    #log{position:fixed;left:8px;top:8px;background:rgba(0,0,0,0.6);padding:6px 8px;border-radius:6px;font-size:12px;z-index:40}
    #bigMatch{position:fixed;left:8px;top:48px;font-size:18px;font-weight:700;color:#fff;text-shadow:0 0 6px #000;z-index:40}

    /* Botón circular de foto/record */
    .cameraBar { position: fixed; left: 50%; bottom: 22px; transform: translateX(-50%); z-index: 11000; display:flex; align-items:center; justify-content:center; }
    .shutterBtn {
      width: 88px; height: 88px; border-radius: 50%;
      background: linear-gradient(180deg,#ff5fb2,#ff2f87);
      border: 6px solid rgba(255,255,255,0.15);
      box-shadow: 0 8px 20px rgba(0,0,0,0.6);
      display:flex; align-items:center; justify-content:center;
      position:relative; touch-action: manipulation; -webkit-tap-highlight-color: transparent;
    }
    .shutterInner {
      width: 64px; height: 64px; border-radius: 50%;
      background: #fff;
      transition: transform 120ms ease;
      display:flex; align-items:center; justify-content:center;
    }
    .recording .shutterInner { background: #000; transform: scale(0.78); border-radius: 14px; }
    .recDot {
      width:12px; height:12px; border-radius:50%; background:#ff2b2b; position:absolute; top:8px; right:8px; display:none;
    }
    .recording .recDot { display:block; box-shadow:0 0 12px rgba(255,0,0,0.7); }

    /* aro de progreso durante la hold->record timeout */
    .progressRing { position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; transform: rotate(-90deg); }
    .progressRing svg { width:100%; height:100%; }
    .progressRing circle { fill:none; stroke:rgba(255,255,255,0.18); stroke-width:6; stroke-linecap:round; }
    .progressRing .progress { stroke: #fff; stroke-width:6; stroke-linecap:round; stroke-dasharray: 283; stroke-dashoffset: 283; transition: stroke-dashoffset 0.08s linear; }

    /* indicador texto */
    #cameraHelp { position:fixed; left:50%; bottom:120px; transform:translateX(-50%); z-index:11001; color:#fff; font-size:14px; opacity:0.9; pointer-events:none;}
  </style>
</head>
<body>
  <div id="videoWrapper">
    <video id="cam" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div id="overlayContainer"></div>

  <div id="controls">
    <button id="testShow" class="ctrlBtn">Mostrar animación de prueba</button>
    <button id="testHide" class="ctrlBtn">Ocultar animación</button>
    <button id="toggleMode" class="ctrlBtn">Modo: Precisión</button>
  </div>

  <!-- Botón circular foto/record -->
  <div class="cameraBar">
    <div id="shutter" class="shutterBtn" role="button" aria-label="Botón cámara">
      <div class="progressRing" aria-hidden="true">
        <svg viewBox="0 0 100 100">
          <circle cx="50" cy="50" r="45" stroke-opacity="0.25"></circle>
          <circle class="progress" cx="50" cy="50" r="45" stroke="#fff"></circle>
        </svg>
      </div>
      <div class="recDot"></div>
      <div class="shutterInner"></div>
    </div>
  </div>
  <div id="cameraHelp">Click: foto · Mantén: grabar</div>

  <button id="startBtn">Activar AR</button>

  <div id="log">iniciando...</div>
  <div id="bigMatch">Match: --</div>

<script>
/* ---------- CONFIG (igual que antes) ---------- */
const TARGET_URL = './ilustracion.png';
const ANIM_URL = './Animacion.webm';
let RES_SCALE = 0.70;
let FRAME_SKIP = 2;
let MODE = 'precision';
const REQUIRED_MATCHES = 10;
const REQUIRED_INLIERS = 8;
const CENTROID_THRESHOLD = 0.20;
/* ---------------------------------------------- */

const cam = document.getElementById('cam');
const overlay = document.getElementById('overlay');
const overlayContainer = document.getElementById('overlayContainer');
const startBtn = document.getElementById('startBtn');
const logEl = document.getElementById('log');
const bigMatch = document.getElementById('bigMatch');
const testShow = document.getElementById('testShow');
const testHide = document.getElementById('testHide');
const toggleMode = document.getElementById('toggleMode');

let worker = null;
let streaming = false;
let procW = 1, procH = 1;
let offscreenForTransfer = null;
let frameCounter = 0;
let templW = 0, templH = 0;
let videoStream = null; // referencia al MediaStream usada para recorder

function log(s){ logEl.textContent = s; console.log(s); }

/* overlay video markup igual que antes */
const overlayVideoMarkup = (filename) => `
  <video id="fxVideo" autoplay loop muted playsinline preload="auto" crossorigin="anonymous" style="background:transparent;display:block;">
    <source src="${filename}" type="video/webm">
    <source src="${filename.replace('.webm','.mp4')}" type="video/mp4">
  </video>`;

/* Mostrar/ocultar overlay (centrado sin rotación) */
function showOverlayCenteredFixed(sizePx){
  let w = sizePx;
  let h = Math.round(sizePx * (templH && templW ? (templH / templW) : 1));
  if (!templW || !templH) h = w;
  if (!document.getElementById('fxVideo')) overlayContainer.innerHTML = overlayVideoMarkup(ANIM_URL);
  const v = document.getElementById('fxVideo');
  overlayContainer.style.width = Math.max(10, w) + 'px';
  overlayContainer.style.height = Math.max(10, h) + 'px';
  overlayContainer.style.display = 'block';
  overlayContainer.style.visibility = 'visible';
  try { v.play().then(()=>{ log('video play ok'); }).catch(()=>{}); } catch(e){}
}
function hideOverlay(){ const fx = document.getElementById('fxVideo'); if (fx) try{ fx.pause(); }catch(e){} overlayContainer.style.display='none'; overlayContainer.style.visibility='hidden'; }

/* botones de control (igual que antes) */
testShow.addEventListener('click', ()=> showOverlayCenteredFixed(Math.round(window.innerWidth*0.5)));
testHide.addEventListener('click', ()=> hideOverlay());
toggleMode.addEventListener('click', ()=>{
  if (MODE === 'precision'){ MODE = 'speed'; RES_SCALE = 0.28; FRAME_SKIP = 4; toggleMode.textContent = 'Modo: Velocidad'; log('Modo velocidad'); }
  else { MODE = 'precision'; RES_SCALE = 0.70; FRAME_SKIP = 2; toggleMode.textContent = 'Modo: Precisión'; log('Modo precisión'); }
});

/* cámara */
startBtn.addEventListener('click', async ()=>{ startBtn.style.display='none'; log('Activando cámara...'); await startCamera(); });

async function startCamera(){
  try {
    videoStream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:true});
    cam.srcObject = videoStream;
    await cam.play();
    streaming = true;
    resizeCanvas();
    initWorker();
    scheduleFrame();
  } catch(e){ alert('Error al abrir la cámara: ' + e.message); console.error(e); }
}

function resizeCanvas(){
  overlay.width = cam.videoWidth; overlay.height = cam.videoHeight;
  overlay.style.width = cam.clientWidth + 'px'; overlay.style.height = cam.clientHeight + 'px';
  procW = Math.max(1, Math.floor(cam.videoWidth * RES_SCALE));
  procH = Math.max(1, Math.floor(cam.videoHeight * RES_SCALE));
  try { offscreenForTransfer = new OffscreenCanvas(procW, procH); } catch(e) { const c = document.createElement('canvas'); c.width = procW; c.height = procH; offscreenForTransfer = c; }
}

/* worker init (igual) */
function initWorker(){
  if (worker) { worker.terminate(); worker = null; }
  worker = new Worker('worker.js');
  worker.onmessage = (ev)=>{
    const d = ev.data;
    if (d.type === 'ready'){ log('Worker ready — cargando template...'); worker.postMessage({type:'init', targetUrl: TARGET_URL, procW, procH}); }
    else if (d.type === 'log'){ console.log('worker:', d.msg); }
    else if (d.type === 'error'){ console.error('worker error:', d.msg); }
    else if (d.type === 'templateInfo'){ templW = d.w; templH = d.h; console.log('templ size from worker', templW, templH); }
    else if (d.type === 'result'){ handleWorkerResult(d); }
  };
}

/* mapping mejorado usando bounding rect del video (como antes) */
function handleWorkerResult(d){
  bigMatch.textContent = `Matches: ${d.matches} | Inliers: ${d.inliers}`;

  if (!d.corners || d.matches < REQUIRED_MATCHES || d.inliers < REQUIRED_INLIERS){
    hideOverlay();
    return;
  }

  const vRect = cam.getBoundingClientRect();
  const scaleX_video = vRect.width / cam.videoWidth;
  const scaleY_video = vRect.height / cam.videoHeight;
  const videoLeft = vRect.left + window.scrollX;
  const videoTop = vRect.top + window.scrollY;

  const cx_proc = (d.corners[0] + d.corners[2] + d.corners[4] + d.corners[6]) / 4.0;
  const cy_proc = (d.corners[1] + d.corners[3] + d.corners[5] + d.corners[7]) / 4.0;

  const cx_screen = videoLeft + cx_proc * scaleX_video;
  const cy_screen = videoTop + cy_proc * scaleY_video;

  const screenCenterX = window.scrollX + (window.innerWidth / 2);
  const screenCenterY = window.scrollY + (window.innerHeight / 2);

  const dx = cx_screen - screenCenterX;
  const dy = cy_screen - screenCenterY;
  const diag = Math.hypot(window.innerWidth, window.innerHeight);
  const distNorm = Math.hypot(dx, dy) / diag;

  if (distNorm > CENTROID_THRESHOLD){ hideOverlay(); return; }

  const sizePx = Math.round(Math.min(window.innerWidth * 0.6, window.innerHeight * 0.6));
  showOverlayCenteredFixed(sizePx);
}

/* enviar frame al worker */
async function sendFrameToWorker(){
  if (!streaming || !worker) return;
  const newW = Math.max(1, Math.floor(cam.videoWidth * RES_SCALE));
  const newH = Math.max(1, Math.floor(cam.videoHeight * RES_SCALE));
  if (newW !== procW || newH !== procH){ procW = newW; procH = newH; resizeCanvas(); worker.postMessage({type:'resize', procW, procH}); }

  try {
    const ctx2 = offscreenForTransfer.getContext('2d');
    ctx2.drawImage(cam, 0, 0, procW, procH);
    let bitmap;
    if (offscreenForTransfer.transferToImageBitmap){
      bitmap = offscreenForTransfer.transferToImageBitmap();
    } else {
      const blob = await new Promise(r=> offscreenForTransfer.toBlob(r,'image/png'));
      bitmap = await createImageBitmap(blob);
    }
    worker.postMessage({type:'frame', bitmap: bitmap}, [bitmap]);
  } catch(err){
    console.error('sendFrameToWorker err', err);
  }
}

/* scheduling */
function scheduleFrame(){
  if (!streaming) return;
  frameCounter = (frameCounter + 1) % FRAME_SKIP;
  if (cam.requestVideoFrameCallback){
    cam.requestVideoFrameCallback(()=>{ if (frameCounter===0) sendFrameToWorker(); scheduleFrame(); });
  } else {
    requestAnimationFrame(()=>{ if (frameCounter===0) sendFrameToWorker(); scheduleFrame(); });
  }
}

/* cleanup */
window.addEventListener('pagehide', ()=>{
  try{ if (worker) worker.terminate(); }catch(e){}
  try{ const s = cam.srcObject; if (s) s.getTracks().forEach(t=>t.stop()); }catch(e){}
});

/* ---------------------------
   FOTO / GRABACIÓN (UI)
   --------------------------- */

const shutter = document.getElementById('shutter');
const shutterInner = document.querySelector('.shutterInner');
const progressCircle = document.querySelector('.progressRing .progress');
const recDot = document.querySelector('.recDot');

let holdTimer = null;
let isRecording = false;
let mediaRecorder = null;
let recordedChunks = [];
const HOLD_TO_RECORD_MS = 400; // tiempo necesario para iniciar grabación
const MAX_RECORD_MS = 60 * 1000; // límite opcional (1 min)
let recordTimeout = null;

// helper: descargar blob
function downloadBlob(blob, filename){
  const a = document.createElement('a');
  const url = URL.createObjectURL(blob);
  a.href = url; a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 5000);
}

// tomar foto ahora (captura del video)
function takePhoto(){
  if (!streaming) { console.warn('no stream'); return; }
  const w = cam.videoWidth, h = cam.videoHeight;
  const c = document.createElement('canvas'); c.width = w; c.height = h;
  const cx = c.getContext('2d');
  // dibujar frame real (no el offscreen reduzido)
  cx.drawImage(cam, 0, 0, w, h);
  c.toBlob((blob)=>{
    if (!blob) return;
    const ts = Date.now();
    downloadBlob(blob, `foto_ar_${ts}.png`);
  }, 'image/png');
}

// inicializar MediaRecorder si es posible
function initMediaRecorder(){
  if (!videoStream) { console.warn('mediaStream no disponible'); return null; }
  let options = {};
  // prefer webm vp9/avc si disponible
  if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) options.mimeType = 'video/webm;codecs=vp9';
  else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) options.mimeType = 'video/webm;codecs=vp8';
  else if (MediaRecorder.isTypeSupported('video/mp4')) options.mimeType = 'video/mp4';
  try {
    const mr = new MediaRecorder(videoStream, options);
    return mr;
  } catch(e){
    console.error('MediaRecorder init error', e);
    return null;
  }
}

function startRecording(){
  if (!videoStream) { console.warn('no stream'); return; }
  if (isRecording) return;
  mediaRecorder = initMediaRecorder();
  if (!mediaRecorder){ log('grabación no soportada en este navegador'); return; }
  recordedChunks = [];
  mediaRecorder.ondataavailable = (e)=>{ if (e.data && e.data.size) recordedChunks.push(e.data); };
  mediaRecorder.onstop = ()=> {
    const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType || 'video/webm' });
    const ts = Date.now();
    downloadBlob(blob, `video_ar_${ts}.webm`);
    recordedChunks = [];
    isRecording = false;
    shutter.classList.remove('recording');
    recDot.style.display = 'none';
    log('Grabación finalizada');
  };
  mediaRecorder.start(200); // recolectar cada 200ms
  isRecording = true;
  shutter.classList.add('recording');
  recDot.style.display = 'block';
  log('Grabando...');
  // opcional: límite máximo para la grabación
  recordTimeout = setTimeout(()=>{ if (isRecording) stopRecording(); }, MAX_RECORD_MS);
}

function stopRecording(){
  if (!isRecording || !mediaRecorder) return;
  try { mediaRecorder.stop(); } catch(e){ console.warn(e); }
  if (recordTimeout){ clearTimeout(recordTimeout); recordTimeout = null; }
}

// animar anillo según progreso (0..1)
function setProgress(p){
  // círculo r=45 -> perímetro ~ 2πr ≈ 283
  const dash = 283 * (1 - Math.max(0, Math.min(1, p)));
  progressCircle.style.strokeDashoffset = String(dash);
}

/* lógica de hold/click combinada (mouse + touch) */
let holdStartTime = 0;
let progressRAF = null;

function onPressStart(evt){
  evt.preventDefault();
  // start timer to enter recording mode
  holdStartTime = performance.now();
  setProgress(1);
  // animate progress down to 0 in HOLD_TO_RECORD_MS
  const start = holdStartTime;
  function tick(){
    const now = performance.now();
    const elapsed = now - start;
    const p = Math.max(0, 1 - (elapsed / HOLD_TO_RECORD_MS));
    setProgress(p);
    if (elapsed >= HOLD_TO_RECORD_MS){
      // start recording
      setProgress(0);
      startRecording();
      cancelHoldAnim();
    } else {
      progressRAF = requestAnimationFrame(tick);
    }
  }
  progressRAF = requestAnimationFrame(tick);
}

function cancelHoldAnim(){
  if (progressRAF) cancelAnimationFrame(progressRAF);
  progressRAF = null;
  setProgress(1); // reset circular progress
}

// release: if recording -> stop; if not recording and held less than threshold -> take photo
function onPressEnd(evt){
  evt.preventDefault();
  const dt = performance.now() - holdStartTime;
  cancelHoldAnim();
  if (isRecording){
    stopRecording();
  } else {
    if (dt < HOLD_TO_RECORD_MS + 60){ // pequeño tolerance
      // short press -> foto
      shutterInner.style.transform = 'scale(0.95)';
      setTimeout(()=> shutterInner.style.transform = '', 90);
      takePhoto();
      log('Foto tomada');
    } else {
      // was held long enough but media recorder maybe not started yet; ensure stop if started
      stopRecording();
    }
  }
  holdStartTime = 0;
}

/* attach mouse + touch events */
(function attachShutterEvents(){
  // mouse
  shutter.addEventListener('mousedown', (e)=> onPressStart(e));
  document.addEventListener('mouseup', (e)=> {
    // only trigger end if pressing started inside shutter (to avoid global mouseup)
    onPressEnd(e);
  });

  // touch
  shutter.addEventListener('touchstart', (e)=> onPressStart(e), {passive:false});
  shutter.addEventListener('touchend', (e)=> onPressEnd(e), {passive:false});
  shutter.addEventListener('touchcancel', (e)=> onPressEnd(e), {passive:false});
})();

/* ensure videoStream variable set when camera started: already assigned in startCamera */
</script>
</body>
</html>
