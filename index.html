<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>AR Camiseta — con foto/record (.mp4 preferido)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <style>
    html,body{margin:0;height:100%;background:#000;color:#fff;font-family:Arial, sans-serif}
    #videoWrapper{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;overflow:hidden}
    video#cam{width:100%;height:100%;object-fit:cover;}
    canvas#overlay{position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none; z-index:20}
    #overlayContainer{position:fixed; left:50%; top:50%; pointer-events:none; z-index:9999; display:none; transform-origin:center center; background:transparent; transform:translate(-50%,-50%);}
    #overlayContainer > video { display:block; width:100%; height:100%; background:transparent; object-fit:cover; }
    #controls{position:fixed; right:12px; top:60px; z-index:10000; display:flex; flex-direction:column; gap:8px}
    .ctrlBtn{padding:10px 12px;border-radius:8px;border:none;background:#ff4fa8;color:#fff;font-weight:600}
    #startBtn{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);padding:14px 18px;background:#ff4fa8;border-radius:10px;border:none;color:#fff;font-size:18px;z-index:40}
    #log{position:fixed;left:8px;top:8px;background:rgba(0,0,0,0.6);padding:6px 8px;border-radius:6px;font-size:12px;z-index:40}
    #bigMatch{position:fixed;left:8px;top:48px;font-size:18px;font-weight:700;color:#fff;text-shadow:0 0 6px #000;z-index:40}

    /* Botón circular de foto/record */
    .cameraBar { position: fixed; left: 50%; bottom: 22px; transform: translateX(-50%); z-index: 11000; display:flex; align-items:center; justify-content:center; }
    .shutterBtn {
      width: 88px; height: 88px; border-radius: 50%;
      background: linear-gradient(180deg,#ff5fb2,#ff2f87);
      border: 6px solid rgba(255,255,255,0.15);
      box-shadow: 0 8px 20px rgba(0,0,0,0.6);
      display:flex; align-items:center; justify-content:center;
      position:relative; touch-action: manipulation; -webkit-tap-highlight-color: transparent;
    }
    .shutterInner {
      width: 64px; height: 64px; border-radius: 50%;
      background: #fff;
      transition: transform 120ms ease;
      display:flex; align-items:center; justify-content:center;
    }
    .recording .shutterInner { background: #000; transform: scale(0.78); border-radius: 14px; }
    .recDot {
      width:12px; height:12px; border-radius:50%; background:#ff2b2b; position:absolute; top:8px; right:8px; display:none;
    }
    .recording .recDot { display:block; box-shadow:0 0 12px rgba(255,0,0,0.7); }

    /* aro de progreso durante la hold->record timeout */
    .progressRing { position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; transform: rotate(-90deg); }
    .progressRing svg { width:100%; height:100%; }
    .progressRing circle { fill:none; stroke:rgba(255,255,255,0.18); stroke-width:6; stroke-linecap:round; }
    .progressRing .progress { stroke: #fff; stroke-width:6; stroke-linecap:round; stroke-dasharray: 283; stroke-dashoffset: 283; transition: stroke-dashoffset 0.08s linear; }
  </style>
</head>
<body>
  <div id="videoWrapper">
    <video id="cam" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div id="overlayContainer"></div>

  <div id="controls">
    <button id="testShow" class="ctrlBtn">Mostrar animación de prueba</button>
    <button id="testHide" class="ctrlBtn">Ocultar animación</button>
    <button id="toggleMode" class="ctrlBtn">Modo: Precisión</button>
  </div>

  <!-- Botón circular foto/record (sin texto de ayuda) -->
  <div class="cameraBar">
    <div id="shutter" class="shutterBtn" role="button" aria-label="Botón cámara">
      <div class="progressRing" aria-hidden="true">
        <svg viewBox="0 0 100 100">
          <circle cx="50" cy="50" r="45" stroke-opacity="0.25"></circle>
          <circle class="progress" cx="50" cy="50" r="45" stroke="#fff"></circle>
        </svg>
      </div>
      <div class="recDot"></div>
      <div class="shutterInner"></div>
    </div>
  </div>

  <button id="startBtn">Activar AR</button>

  <div id="log">iniciando...</div>
  <div id="bigMatch">Match: --</div>

<script>
/* ---------- CONFIG ---------- */
const TARGET_URL = './medusa1.png';
const ANIM_URL = './medusa.webm';
let RES_SCALE = 0.70;
let FRAME_SKIP = 2;
let MODE = 'precision';
const REQUIRED_MATCHES = 10;
const REQUIRED_INLIERS = 8;
const CENTROID_THRESHOLD = 0.20;
/* ---------------------------- */

const cam = document.getElementById('cam');
const overlay = document.getElementById('overlay');
const overlayContainer = document.getElementById('overlayContainer');
const startBtn = document.getElementById('startBtn');
const logEl = document.getElementById('log');
const bigMatch = document.getElementById('bigMatch');
const testShow = document.getElementById('testShow');
const testHide = document.getElementById('testHide');
const toggleMode = document.getElementById('toggleMode');

let worker = null;
let streaming = false;
let procW = 1, procH = 1;
let offscreenForTransfer = null;
let frameCounter = 0;
let templW = 0, templH = 0;
let videoStream = null; // referencia al MediaStream usada para recorder

function log(s){ logEl.textContent = s; console.log(s); }

const overlayVideoMarkup = (filename) => `
  <video id="fxVideo" autoplay loop muted playsinline preload="auto" crossorigin="anonymous" style="background:transparent;display:block;">
    <source src="${filename}" type="video/webm">
    <source src="${filename.replace('.webm','.mp4')}" type="video/mp4">
  </video>`;

function showOverlayCenteredFixed(sizePx){
  let w = sizePx;
  let h = Math.round(sizePx * (templH && templW ? (templH / templW) : 1));
  if (!templW || !templH) h = w;
  if (!document.getElementById('fxVideo')) overlayContainer.innerHTML = overlayVideoMarkup(ANIM_URL);
  const v = document.getElementById('fxVideo');
  overlayContainer.style.width = Math.max(10, w) + 'px';
  overlayContainer.style.height = Math.max(10, h) + 'px';
  overlayContainer.style.display = 'block';
  overlayContainer.style.visibility = 'visible';
  try { v.play().then(()=>{ log('video play ok'); }).catch(()=>{}); } catch(e){}
}
function hideOverlay(){ const fx = document.getElementById('fxVideo'); if (fx) try{ fx.pause(); }catch(e){} overlayContainer.style.display='none'; overlayContainer.style.visibility='hidden'; }

testShow.addEventListener('click', ()=> showOverlayCenteredFixed(Math.round(window.innerWidth*0.5)));
testHide.addEventListener('click', ()=> hideOverlay());
toggleMode.addEventListener('click', ()=>{
  if (MODE === 'precision'){ MODE = 'speed'; RES_SCALE = 0.28; FRAME_SKIP = 4; toggleMode.textContent = 'Modo: Velocidad'; log('Modo velocidad'); }
  else { MODE = 'precision'; RES_SCALE = 0.70; FRAME_SKIP = 2; toggleMode.textContent = 'Modo: Precisión'; log('Modo precisión'); }
});

startBtn.addEventListener('click', async ()=>{ startBtn.style.display='none'; log('Activando cámara...'); await startCamera(); });

async function startCamera(){
  try {
    videoStream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:true});
    cam.srcObject = videoStream;
    await cam.play();
    streaming = true;
    resizeCanvas();
    initWorker();
    scheduleFrame();
  } catch(e){ alert('Error al abrir la cámara: ' + e.message); console.error(e); }
}

function resizeCanvas(){
  overlay.width = cam.videoWidth; overlay.height = cam.videoHeight;
  overlay.style.width = cam.clientWidth + 'px'; overlay.style.height = cam.clientHeight + 'px';
  procW = Math.max(1, Math.floor(cam.videoWidth * RES_SCALE));
  procH = Math.max(1, Math.floor(cam.videoHeight * RES_SCALE));
  try { offscreenForTransfer = new OffscreenCanvas(procW, procH); } catch(e) { const c = document.createElement('canvas'); c.width = procW; c.height = procH; offscreenForTransfer = c; }
}

/* worker init */
function initWorker(){
  if (worker) { worker.terminate(); worker = null; }
  worker = new Worker('worker.js');
  worker.onmessage = (ev)=>{
    const d = ev.data;
    if (d.type === 'ready'){ log('Worker ready — cargando template...'); worker.postMessage({type:'init', targetUrl: TARGET_URL, procW, procH}); }
    else if (d.type === 'log'){ console.log('worker:', d.msg); }
    else if (d.type === 'error'){ console.error('worker error:', d.msg); }
    else if (d.type === 'templateInfo'){ templW = d.w; templH = d.h; console.log('templ size from worker', templW, templH); }
    else if (d.type === 'result'){ handleWorkerResult(d); }
  };
}

/* mapping using video DOM rect (handles object-fit cropping) */
function handleWorkerResult(d){
  bigMatch.textContent = `Matches: ${d.matches} | Inliers: ${d.inliers}`;

  if (!d.corners || d.matches < REQUIRED_MATCHES || d.inliers < REQUIRED_INLIERS){
    hideOverlay();
    return;
  }

  const vRect = cam.getBoundingClientRect();
  const scaleX_video = vRect.width / cam.videoWidth;
  const scaleY_video = vRect.height / cam.videoHeight;
  const videoLeft = vRect.left + window.scrollX;
  const videoTop = vRect.top + window.scrollY;

  const cx_proc = (d.corners[0] + d.corners[2] + d.corners[4] + d.corners[6]) / 4.0;
  const cy_proc = (d.corners[1] + d.corners[3] + d.corners[5] + d.corners[7]) / 4.0;

  const cx_screen = videoLeft + cx_proc * scaleX_video;
  const cy_screen = videoTop + cy_proc * scaleY_video;

  const screenCenterX = window.scrollX + (window.innerWidth / 2);
  const screenCenterY = window.scrollY + (window.innerHeight / 2);

  const dx = cx_screen - screenCenterX;
  const dy = cy_screen - screenCenterY;
  const diag = Math.hypot(window.innerWidth, window.innerHeight);
  const distNorm = Math.hypot(dx, dy) / diag;

  if (distNorm > CENTROID_THRESHOLD){ hideOverlay(); return; }

  const sizePx = Math.round(Math.min(window.innerWidth * 0.6, window.innerHeight * 0.6));
  showOverlayCenteredFixed(sizePx);
}

/* send frame to worker */
async function sendFrameToWorker(){
  if (!streaming || !worker) return;
  const newW = Math.max(1, Math.floor(cam.videoWidth * RES_SCALE));
  const newH = Math.max(1, Math.floor(cam.videoHeight * RES_SCALE));
  if (newW !== procW || newH !== procH){ procW = newW; procH = newH; resizeCanvas(); worker.postMessage({type:'resize', procW, procH}); }

  try {
    const ctx2 = offscreenForTransfer.getContext('2d');
    ctx2.drawImage(cam, 0, 0, procW, procH);
    let bitmap;
    if (offscreenForTransfer.transferToImageBitmap){
      bitmap = offscreenForTransfer.transferToImageBitmap();
    } else {
      const blob = await new Promise(r=> offscreenForTransfer.toBlob(r,'image/png'));
      bitmap = await createImageBitmap(blob);
    }
    worker.postMessage({type:'frame', bitmap: bitmap}, [bitmap]);
  } catch(err){
    console.error('sendFrameToWorker err', err);
  }
}

/* scheduling */
function scheduleFrame(){
  if (!streaming) return;
  frameCounter = (frameCounter + 1) % FRAME_SKIP;
  if (cam.requestVideoFrameCallback){
    cam.requestVideoFrameCallback(()=>{ if (frameCounter===0) sendFrameToWorker(); scheduleFrame(); });
  } else {
    requestAnimationFrame(()=>{ if (frameCounter===0) sendFrameToWorker(); scheduleFrame(); });
  }
}

/* cleanup */
window.addEventListener('pagehide', ()=>{
  try{ if (worker) worker.terminate(); }catch(e){}
  try{ const s = cam.srcObject; if (s) s.getTracks().forEach(t=>t.stop()); }catch(e){}
});

/* ---------------------------
   FOTO / GRABACIÓN (UI)
   --------------------------- */

const shutter = document.getElementById('shutter');
const shutterInner = document.querySelector('.shutterInner');
const progressCircle = document.querySelector('.progressRing .progress');
const recDot = document.querySelector('.recDot');

let holdTimer = null;
let isRecording = false;
let mediaRecorder = null;
let recordedChunks = [];
const HOLD_TO_RECORD_MS = 400; // tiempo para iniciar grabación
const MAX_RECORD_MS = 60 * 1000; // 1 min
let recordTimeout = null;

function downloadBlob(blob, filename){
  const a = document.createElement('a');
  const url = URL.createObjectURL(blob);
  a.href = url; a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 5000);
}

function takePhoto(){
  if (!streaming) { console.warn('no stream'); return; }
  const w = cam.videoWidth, h = cam.videoHeight;
  const c = document.createElement('canvas'); c.width = w; c.height = h;
  const cx = c.getContext('2d');
  cx.drawImage(cam, 0, 0, w, h);
  c.toBlob((blob)=>{
    if (!blob) return;
    const ts = Date.now();
    downloadBlob(blob, `foto_ar_${ts}.png`);
  }, 'image/png');
}

// Preferir mp4; si no está disponible, usar webm
function initMediaRecorder(){
  if (!videoStream) { console.warn('mediaStream no disponible'); return null; }
  let mr = null;
  // prefer mp4
  const tryTypes = [
    'video/mp4;codecs="avc1.42E01E"', // common mp4 baseline (may not be supported)
    'video/mp4',
    'video/webm;codecs=vp9',
    'video/webm;codecs=vp8',
    'video/webm'
  ];
  for (const t of tryTypes){
    try {
      if (!MediaRecorder.isTypeSupported || MediaRecorder.isTypeSupported(t)){
        mr = new MediaRecorder(videoStream, t ? { mimeType: t } : undefined);
        console.log('MediaRecorder init type=', t);
        return mr;
      }
    } catch(e){
      console.warn('MediaRecorder try failed for', t, e);
      mr = null;
    }
  }
  // último intento sin opciones
  try {
    mr = new MediaRecorder(videoStream);
    return mr;
  } catch(e){ console.error('MediaRecorder not supported', e); return null; }
}

function startRecording(){
  if (!videoStream) { console.warn('no stream'); return; }
  if (isRecording) return;
  mediaRecorder = initMediaRecorder();
  if (!mediaRecorder){ log('grabación no soportada en este navegador'); return; }
  recordedChunks = [];
  mediaRecorder.ondataavailable = (e)=>{ if (e.data && e.data.size) recordedChunks.push(e.data); };
  mediaRecorder.onstop = ()=> {
    const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType || 'video/webm' });
    const ts = Date.now();
    // elegir extensión según mimeType
    let ext = 'webm';
    if (mediaRecorder.mimeType && mediaRecorder.mimeType.includes('mp4')) ext = 'mp4';
    else if (mediaRecorder.mimeType && mediaRecorder.mimeType.includes('webm')) ext = 'webm';
    downloadBlob(blob, `video_ar_${ts}.${ext}`);
    recordedChunks = [];
    isRecording = false;
    shutter.classList.remove('recording');
    recDot.style.display = 'none';
    log('Grabación finalizada');
  };
  mediaRecorder.start(200);
  isRecording = true;
  shutter.classList.add('recording');
  recDot.style.display = 'block';
  log('Grabando...');
  recordTimeout = setTimeout(()=>{ if (isRecording) stopRecording(); }, MAX_RECORD_MS);
}

function stopRecording(){
  if (!isRecording || !mediaRecorder) return;
  try { mediaRecorder.stop(); } catch(e){ console.warn(e); }
  if (recordTimeout){ clearTimeout(recordTimeout); recordTimeout = null; }
}

function setProgress(p){ const dash = 283 * (1 - Math.max(0, Math.min(1, p))); progressCircle.style.strokeDashoffset = String(dash); }

let progressRAF = null;
let holdStartTime = 0;

function onPressStart(evt){
  evt.preventDefault();
  holdStartTime = performance.now();
  setProgress(1);
  const start = holdStartTime;
  function tick(){
    const now = performance.now();
    const elapsed = now - start;
    const p = Math.max(0, 1 - (elapsed / HOLD_TO_RECORD_MS));
    setProgress(p);
    if (elapsed >= HOLD_TO_RECORD_MS){
      setProgress(0);
      startRecording();
      cancelHoldAnim();
    } else {
      progressRAF = requestAnimationFrame(tick);
    }
  }
  progressRAF = requestAnimationFrame(tick);
}

function cancelHoldAnim(){
  if (progressRAF) cancelAnimationFrame(progressRAF);
  progressRAF = null;
  setProgress(1);
}

function onPressEnd(evt){
  evt.preventDefault();
  const dt = performance.now() - holdStartTime;
  cancelHoldAnim();
  if (isRecording){
    stopRecording();
  } else {
    if (dt < HOLD_TO_RECORD_MS + 60){
      shutterInner.style.transform = 'scale(0.95)';
      setTimeout(()=> shutterInner.style.transform = '', 90);
      takePhoto();
      log('Foto tomada');
    } else {
      stopRecording();
    }
  }
  holdStartTime = 0;
}

/* attach events */
(function attachShutterEvents(){
  shutter.addEventListener('mousedown', (e)=> onPressStart(e));
  document.addEventListener('mouseup', (e)=> onPressEnd(e));
  shutter.addEventListener('touchstart', (e)=> onPressStart(e), {passive:false});
  shutter.addEventListener('touchend', (e)=> onPressEnd(e), {passive:false});
  shutter.addEventListener('touchcancel', (e)=> onPressEnd(e), {passive:false});
})();

</script>
</body>
</html>
