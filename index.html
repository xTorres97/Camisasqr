<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>AR Camiseta - Worker + OpenCV.js</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <style>
    html,body{margin:0;height:100%;background:#000;color:#fff;font-family:Arial, sans-serif}
    #videoWrapper{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;overflow:hidden}
    video#cam{width:100%;height:100%;object-fit:cover;}
    canvas#overlay{position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none; z-index:20}
    #overlayContainer{position:fixed; left:0; top:0; pointer-events:none; z-index:9999; display:none; transform-origin:center center; background:transparent; will-change: transform, opacity; -webkit-transform: translate3d(0,0,0);}
    #controls{position:fixed; right:12px; top:60px; z-index:10000; display:flex; flex-direction:column; gap:8px}
    .ctrlBtn{padding:10px 12px;border-radius:8px;border:none;background:#ff4fa8;color:#fff;font-weight:600}
    #startBtn{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);padding:14px 18px;background:#ff4fa8;border-radius:10px;border:none;color:#fff;font-size:18px;z-index:40}
    #log{position:fixed;left:8px;top:8px;background:rgba(0,0,0,0.6);padding:6px 8px;border-radius:6px;font-size:12px;z-index:40}
    #bigMatch{position:fixed;left:8px;top:48px;font-size:18px;font-weight:700;color:#fff;text-shadow:0 0 6px #000;z-index:40}
    #forcePlay{position:fixed;left:50%;top:70%;transform:translate(-50%,-50%);z-index:10001;padding:12px 18px;background:#ff4fa8;color:#fff;border-radius:8px;border:none;display:none}
  </style>
</head>
<body>
  <div id="videoWrapper">
    <video id="cam" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div id="overlayContainer"></div>

  <div id="controls">
    <button id="testShow" class="ctrlBtn">Mostrar animación de prueba</button>
    <button id="testHide" class="ctrlBtn">Ocultar animación</button>
    <button id="toggleMode" class="ctrlBtn">Modo: Precisión</button>
  </div>

  <button id="startBtn">Activar AR</button>
  <button id="forcePlay">Toca para reproducir animación</button>

  <div id="log">iniciando...</div>
  <div id="bigMatch">Match: --</div>

  <script>
  // ---------- CONFIG ----------
  const TARGET_URL = './ilustracion.png';
  const ANIM_URL = './Animacion.webm';

  // modos y performance
  let RES_SCALE = 0.40;     // escala de procesamiento (ajusta con toggle)
  let FRAME_SKIP = 3;
  let MODE = 'precision';   // 'precision'|'speed'

  // DOM
  const cam = document.getElementById('cam');
  const overlay = document.getElementById('overlay');
  const ctx = overlay.getContext('2d');
  const overlayContainer = document.getElementById('overlayContainer');
  const startBtn = document.getElementById('startBtn');
  const logEl = document.getElementById('log');
  const bigMatch = document.getElementById('bigMatch');
  const testShow = document.getElementById('testShow');
  const testHide = document.getElementById('testHide');
  const toggleMode = document.getElementById('toggleMode');
  const forcePlay = document.getElementById('forcePlay');

  // Worker
  let worker = null;
  let streaming = false;
  let frameCounter = 0;
  let procW = 1, procH = 1;
  let offscreenForTransfer = null; // OffscreenCanvas for producing ImageBitmap
  let videoTrackSettings = null;

  function log(s){ logEl.textContent = s; console.log(s); }

  /* overlay video markup (same as before) */
  const overlayVideoMarkup = (filename) => `
    <video id="fxVideo" autoplay loop muted playsinline preload="auto" crossorigin="anonymous" style="background:transparent;display:block;">
      <source src="${filename}" type="video/webm">
      <source src="${filename.replace('.webm','.mp4')}" type="video/mp4">
    </video>`;

  function showOverlayCentered(cx, cy, w, h, angleDeg = 0, small=false){
    const rect = overlay.getBoundingClientRect();
    const screenX = rect.left + cx + window.scrollX;
    const screenY = rect.top + cy + window.scrollY;

    if (!document.getElementById('fxVideo')){
      overlayContainer.innerHTML = overlayVideoMarkup(small ? ANIM_URL.replace('.webm','_small.webm') : ANIM_URL);
    }
    const fx = document.getElementById('fxVideo');
    overlayContainer.style.left = screenX + 'px';
    overlayContainer.style.top  = screenY + 'px';
    overlayContainer.style.width = Math.max(10, w) + 'px';
    overlayContainer.style.height = Math.max(10, h) + 'px';
    overlayContainer.style.display = 'block';
    overlayContainer.style.visibility = 'visible';
    overlayContainer.style.transform = `translate(-50%,-50%) rotate(${angleDeg}deg) translate3d(0,0,0)`;
    fx.style.width = '100%'; fx.style.height = '100%'; fx.style.objectFit = 'cover';
    fx.play().then(()=>{ log('video play ok'); forcePlay.style.display='none'; }).catch(err=>{ log('Autoplay error: '+err); forcePlay.style.display='block'; });
  }
  function hideOverlay(){ const fx = document.getElementById('fxVideo'); if (fx) try{ fx.pause(); }catch(e){} overlayContainer.style.display='none'; overlayContainer.style.visibility='hidden'; }

  forcePlay.addEventListener('click', ()=>{ const fx = document.getElementById('fxVideo'); if (fx) fx.play().catch(()=>{}); forcePlay.style.display='none'; });

  testShow.addEventListener('click', ()=>{ const r = overlay.getBoundingClientRect(); showOverlayCentered(r.width/2, r.height/2, r.width*0.5, r.height*0.5, 0); });
  testHide.addEventListener('click', ()=>{ hideOverlay(); });

  toggleMode.addEventListener('click', ()=>{
    if (MODE === 'precision'){
      MODE = 'speed'; RES_SCALE = 0.22; FRAME_SKIP = 5; toggleMode.textContent = 'Modo: Velocidad'; log('Modo velocidad');
    } else {
      MODE = 'precision'; RES_SCALE = 0.40; FRAME_SKIP = 3; toggleMode.textContent = 'Modo: Precisión'; log('Modo precisión');
    }
    // reinit offscreen with new size on next frame
  });

  startBtn.addEventListener('click', async ()=>{
    startBtn.style.display='none';
    log('Activando cámara...');
    await startCamera();
  });

  async function startCamera(){
    try {
      const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
      cam.srcObject = stream;
      await cam.play();
      streaming = true;
      videoTrackSettings = stream.getVideoTracks()[0].getSettings();
      resizeCanvas();
      initWorker();
      scheduleFrame(); // start loop
    } catch(e){
      alert('Error al abrir la cámara: ' + e.message);
      console.error(e);
    }
  }

  function resizeCanvas(){
    overlay.width = cam.videoWidth;
    overlay.height = cam.videoHeight;
    overlay.style.width = cam.clientWidth + 'px';
    overlay.style.height = cam.clientHeight + 'px';
    // update proc sizes
    procW = Math.max(1, Math.floor(cam.videoWidth * RES_SCALE));
    procH = Math.max(1, Math.floor(cam.videoHeight * RES_SCALE));
    // create OffscreenCanvas sized for transfer
    try {
      offscreenForTransfer = new OffscreenCanvas(procW, procH);
    } catch(e){
      // fallback: canvas element (slower). We'll create hidden canvas
      const c = document.createElement('canvas');
      c.width = procW; c.height = procH;
      offscreenForTransfer = c; // will use transferToImageBitmap not available -> use bitmapFromCanvas
    }
  }

  /* init worker and send init message */
  function initWorker(){
    if (worker) { worker.terminate(); worker = null; }
    worker = new Worker('worker.js');
    worker.onmessage = (ev) => {
      const d = ev.data;
      if (d.type === 'ready'){
        log('Worker ready — cargando template...');
        // send init (template URL + params)
        worker.postMessage({type:'init', targetUrl: TARGET_URL, procW: procW, procH: procH});
      } else if (d.type === 'log'){
        console.log('worker:', d.msg);
      } else if (d.type === 'result'){
        // Resultado del worker: corners en proc-coords o null
        handleWorkerResult(d);
      } else if (d.type === 'error'){
        console.error('Worker error:', d.msg);
      }
    };
  }

  /* procesa la respuesta del worker */
  function handleWorkerResult(d){
    // d = {type:'result', matches, inliers, corners: [x0,y0,x1,y1,...] or null, angleDeg}
    bigMatch.textContent = `Matches: ${d.matches} | Inliers: ${d.inliers}`;
    if (d.corners && d.corners.length === 8){
      // corners están en coords de imagen procesada (procW x procH). Convertir a canvas overlay coords.
      const scaleX = overlay.width / procW;
      const scaleY = overlay.height / procH;
      const x0 = d.corners[0]*scaleX, y0 = d.corners[1]*scaleY;
      const x1 = d.corners[2]*scaleX, y1 = d.corners[3]*scaleY;
      const x2 = d.corners[4]*scaleX, y2 = d.corners[5]*scaleY;
      const x3 = d.corners[6]*scaleX, y3 = d.corners[7]*scaleY;

      // bbox center/size/angle
      const minX = Math.min(x0,x1,x2,x3), maxX = Math.max(x0,x1,x2,x3);
      const minY = Math.min(y0,y1,y2,y3), maxY = Math.max(y0,y1,y2,y3);
      const centerX = (minX+maxX)/2, centerY = (minY+maxY)/2;
      const drawW = (maxX-minX), drawH = (maxY-minY);
      // angle from edge 0->1
      const angleRad = Math.atan2(y1-y0, x1-x0); const angleDeg = angleRad*180/Math.PI;

      // draw debug polygon (optional)
      ctx.clearRect(0,0,overlay.width,overlay.height);
      ctx.strokeStyle='rgba(0,255,150,0.95)'; ctx.lineWidth=3;
      ctx.beginPath();
      ctx.moveTo(x0,y0); ctx.lineTo(x1,y1); ctx.lineTo(x2,y2); ctx.lineTo(x3,y3); ctx.closePath(); ctx.stroke();

      // show overlay centered
      showOverlayCentered(centerX, centerY, drawW, drawH, angleDeg, MODE==='speed');
    } else {
      // no corners => hide overlay
      ctx.clearRect(0,0,overlay.width,overlay.height);
      hideOverlay();
    }
  }

  /* capture frame, downscale, transfer to worker */
  async function sendFrameToWorker(){
    if (!streaming || !worker) return;
    // recompute procW/procH if RES_SCALE changed
    const newW = Math.max(1, Math.floor(cam.videoWidth * RES_SCALE));
    const newH = Math.max(1, Math.floor(cam.videoHeight * RES_SCALE));
    if (newW !== procW || newH !== procH){
      procW = newW; procH = newH; resizeCanvas(); // reinit offscreen
      // inform worker that proc size changed
      worker.postMessage({type:'resize', procW, procH});
    }

    // draw video into offscreen and transfer as ImageBitmap
    try {
      let ctx2 = offscreenForTransfer.getContext ? offscreenForTransfer.getContext('2d') : offscreenForTransfer.getContext('2d');
      ctx2.drawImage(cam, 0, 0, procW, procH);

      // transfer ImageBitmap
      let bitmap;
      if (offscreenForTransfer.transferToImageBitmap){
        bitmap = offscreenForTransfer.transferToImageBitmap();
      } else {
        // fallback: convert canvas to blob then to ImageBitmap
        const blob = await new Promise(res=> offscreenForTransfer.toBlob(res, 'image/png'));
        bitmap = await createImageBitmap(blob);
      }

      // send to worker (transfer the bitmap)
      worker.postMessage({type:'frame', bitmap: bitmap}, [bitmap]);
    } catch(err){
      console.error('Error sending frame to worker', err);
    }
  }

  /* scheduling: use requestVideoFrameCallback si existe */
  function scheduleFrame(){
    if (!streaming) return;
    frameCounter = (frameCounter + 1) % FRAME_SKIP;
    if (cam.requestVideoFrameCallback){
      cam.requestVideoFrameCallback(()=>{ if (frameCounter===0) sendFrameToWorker(); scheduleFrame(); });
    } else {
      // use rAF fallback
      requestAnimationFrame(()=>{ if (frameCounter===0) sendFrameToWorker(); scheduleFrame(); });
    }
  }

  // init: check page visibility and cleanup
  window.addEventListener('pagehide', ()=>{
    try { if (worker) worker.terminate(); } catch(e){}
    try { const s = cam.srcObject; if (s) s.getTracks().forEach(t=>t.stop()); } catch(e){}
  });

  </script>
</body>
</html>
