<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>AR Camiseta - ORB Matching (mejorado)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <style>
    html,body{margin:0;height:100%;background:#000;color:#fff;font-family:Arial, sans-serif}
    #videoWrapper{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;overflow:hidden}
    video#cam{width:100%;height:100%;object-fit:cover;}
    canvas#overlay{position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none; z-index:20}
    #fxVideo{
      position:fixed;
      left:0; top:0;
      transform-origin:center center;
      display:none;
      pointer-events:none;
      z-index:9999;
      background:transparent;
      will-change:transform;
    }
    #controls{position:fixed; right:12px; top:60px; z-index:10000; display:flex; flex-direction:column; gap:8px}
    .ctrlBtn{padding:10px 12px;border-radius:8px;border:none;background:#ff4fa8;color:#fff;font-weight:600}
    #startBtn{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);padding:14px 18px;background:#ff4fa8;border-radius:10px;border:none;color:#fff;font-size:18px;z-index:40}
    #note{position:fixed;left:0;right:0;bottom:10px;text-align:center;z-index:40;opacity:0.9}
    #log{position:fixed;left:8px;top:8px;background:rgba(0,0,0,0.6);padding:6px 8px;border-radius:6px;font-size:12px;z-index:40}
    #bigMatch{position:fixed;left:8px;top:48px;font-size:20px;font-weight:700;color:#fff;text-shadow:0 0 6px #000;z-index:40}
  </style>
</head>
<body>
  <div id="videoWrapper">
    <video id="cam" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <!-- Video efecto -->
  <video id="fxVideo" autoplay loop muted playsinline preload="auto" crossorigin="anonymous">
    <source src="./animacion.webm" type="video/webm">
  </video>

  <div id="controls">
    <button id="testShow" class="ctrlBtn">Mostrar animación de prueba</button>
    <button id="testHide" class="ctrlBtn">Ocultar animación prueba</button>
  </div>

  <button id="startBtn">Activar AR</button>
  <div id="note">Apunta la cámara hacia la imagen de la camiseta</div>
  <div id="log">listo</div>
  <div id="bigMatch">Match: --</div>

  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
/* ========== CONFIG ========== */
const TARGET_URL = './target_cropped_512.png';
let RES_SCALE = 0.7;         // **reducido para mejorar velocidad**
let FRAME_SKIP = 2;          // procesar cada N frames
let MATCH_RATIO = 0.75;      // ratio test Lowe
let minMatchCount = 6;       // menos exigente para detectar antes
/* =========================== */

const cam = document.getElementById('cam');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');
const startBtn = document.getElementById('startBtn');
const logEl = document.getElementById('log');
const bigMatch = document.getElementById('bigMatch');
const fxVideo = document.getElementById('fxVideo');
const testShow = document.getElementById('testShow');
const testHide = document.getElementById('testHide');

let videoStream = null;
let streaming = false;

let srcMat = null, grayMat = null, templMat = null, templGray = null;
let procCanvas = null, procCtx = null;
let animStart = null;

// ORB/matcher globals
let orb = null;
let bf = null;
let templKeypoints = null;
let templDescriptors = null;

// frame skip
let frameCounter = 0;

function log(s){ logEl.textContent = s; console.log(s); }

/* autoplay helper */
function showPlayHint(){
  if (document.getElementById('playHint')) return;
  const b = document.createElement('button');
  b.id='playHint';
  b.textContent='Toca para reproducir animación';
  Object.assign(b.style, {position:'fixed',left:'50%',top:'75%',transform:'translate(-50%,-50%)',zIndex:100000,padding:'12px 16px',background:'#ff4fa8',color:'#fff',border:'none',borderRadius:'8px'});
  b.onclick = ()=>{ fxVideo.play().catch(()=>{}); b.remove(); };
  document.body.appendChild(b);
}

/* show/hide overlay with rotation and center anchoring */
function showVideoOverlayCentered(cx, cy, w, h, angleDeg=0){
  if (!fxVideo) return;
  // cx,cy are CENTER coords in overlay canvas pixels
  const rect = overlay.getBoundingClientRect();
  const screenX = rect.left + cx + window.scrollX;
  const screenY = rect.top + cy + window.scrollY;

  fxVideo.style.display = 'block';
  fxVideo.style.visibility = 'visible';
  fxVideo.style.left = (screenX) + 'px';
  fxVideo.style.top  = (screenY) + 'px';
  fxVideo.style.width = Math.max(10, w) + 'px';
  fxVideo.style.height = Math.max(10, h) + 'px';
  fxVideo.style.objectFit = 'cover'; // fill box and crop if aspect differs
  fxVideo.style.transform = `translate(-50%,-50%) rotate(${angleDeg}deg)`;

  if (fxVideo.paused) {
    fxVideo.play().then(()=>{ log('video play ok'); }).catch(err=>{ log('video play err: '+err); showPlayHint(); });
  }
}
function hideVideoOverlay(){ if (!fxVideo) return; try{ fxVideo.pause(); }catch(e){} fxVideo.style.display='none'; fxVideo.style.visibility='hidden'; fxVideo.style.transform='translate(-50%,-50%)'; }

/* test buttons */
testShow.addEventListener('click', ()=>{
  const rect = overlay.getBoundingClientRect();
  const cx = rect.width/2, cy = rect.height/2;
  showVideoOverlayCentered(cx, cy, rect.width*0.55, rect.height*0.55, 0);
});
testHide.addEventListener('click', ()=>{ hideVideoOverlay(); });

/* camera */
async function startCamera(){
  try {
    videoStream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
    cam.srcObject = videoStream;
    await cam.play();
    streaming = true;
    resizeCanvas();
    prepareOpenCV();
  } catch(e){
    alert('Error al abrir la cámara: ' + e.message);
    console.error(e);
  }
}
function stopCamera(){ if (videoStream) videoStream.getTracks().forEach(t=>t.stop()); streaming = false; }
function resizeCanvas(){ overlay.width = cam.videoWidth; overlay.height = cam.videoHeight; overlay.style.width = cam.clientWidth + 'px'; overlay.style.height = cam.clientHeight + 'px'; }

/* prepareOpenCV (ORB) */
async function prepareOpenCV(){
  log("Esperando OpenCV...");
  if (typeof cv === "undefined" || !cv.imread){
    let waited=0;
    while((typeof cv === "undefined" || !cv.imread) && waited < 5000){ await new Promise(r=>setTimeout(r,100)); waited += 100; }
  }
  if (typeof cv === "undefined" || !cv.imread){
    alert("OpenCV no cargó");
    return;
  }

  log("OpenCV listo — cargando template (ORB)...");
  const img = new Image();
  img.crossOrigin = "anonymous";
  img.src = TARGET_URL + "?v=" + Date.now();

  img.onload = () => {
    const tmp = document.createElement('canvas');
    tmp.width = img.width; tmp.height = img.height;
    const tctx = tmp.getContext('2d');
    tctx.drawImage(img, 0, 0);

    // cleanup previous
    try { if (templKeypoints) templKeypoints.delete(); } catch(e){}
    try { if (templDescriptors) templDescriptors.delete(); } catch(e){}
    if (templMat) { templMat.delete(); templMat = null; }
    if (templGray) { templGray.delete(); templGray = null; }

    templMat = cv.imread(tmp);
    templGray = new cv.Mat();
    cv.cvtColor(templMat, templGray, cv.COLOR_RGBA2GRAY);

    try { let eq = new cv.Mat(); cv.equalizeHist(templGray, eq); templGray.delete(); templGray = eq; } catch(e){}

    // -> OPTIONAL: rescale template smaller if you want even faster (e.g. 0.85)
    // (leave commented, you can enable if needed)
    // {
    //   const scale = 0.9;
    //   const w = Math.max(8, Math.round(templGray.cols * scale));
    //   const h = Math.max(8, Math.round(templGray.rows * scale));
    //   const tmp2 = document.createElement('canvas'); tmp2.width = w; tmp2.height = h;
    //   tmp2.getContext('2d').drawImage(tmp,0,0,tmp.width,tmp.height,0,0,w,h);
    //   templMat.delete(); templGray.delete();
    //   templMat = cv.imread(tmp2);
    //   templGray = new cv.Mat();
    //   cv.cvtColor(templMat, templGray, cv.COLOR_RGBA2GRAY);
    // }

    // init ORB & BFMatcher
    try {
      orb = new cv.ORB();
    } catch(e){
      try { orb = new cv.ORB(); } catch(err){ console.warn("ORB not available in this build:", err); }
    }
    bf = new cv.BFMatcher(cv.NORM_HAMMING, false);

    templKeypoints = new cv.KeyPointVector();
    templDescriptors = new cv.Mat();
    try {
      orb.detect(templGray, templKeypoints);
      orb.compute(templGray, templKeypoints, templDescriptors);
    } catch(e){
      try {
        orb.detectAndCompute(templGray, new cv.Mat(), templKeypoints, templDescriptors);
      } catch(err){
        console.error("Error ORB detect/compute on template:", err);
        alert("Error: ORB detect/compute no funcionó en esta build de OpenCV.js");
        return;
      }
    }

    log('Template ORB: keypoints=' + templKeypoints.size() + ' descriptors: ' + templDescriptors.rows);

    // prepare proc canvas and mats
    const procW = Math.max(1, Math.floor(cam.videoWidth * RES_SCALE));
    const procH = Math.max(1, Math.floor(cam.videoHeight * RES_SCALE));
    procCanvas = document.createElement('canvas');
    procCanvas.width = procW; procCanvas.height = procH;
    procCtx = procCanvas.getContext('2d', { willReadFrequently: true });

    if (srcMat) { srcMat.delete(); srcMat = null; }
    if (grayMat) { grayMat.delete(); grayMat = null; }

    srcMat = new cv.Mat(procH, procW, cv.CV_8UC4);
    grayMat = new cv.Mat(procH, procW, cv.CV_8UC1);

    animStart = performance.now();
    requestAnimationFrame(processFrame);
  };

  img.onerror = e => { alert("No se pudo cargar " + TARGET_URL); console.error(e); };
}

/* processFrame (ORB + FRAME_SKIP) with rotation & center overlay */
function processFrame(now){
  if (!streaming) return;
  try {
    frameCounter = (frameCounter + 1) % FRAME_SKIP;

    const pW = Math.max(1, Math.floor(cam.videoWidth * RES_SCALE));
    const pH = Math.max(1, Math.floor(cam.videoHeight * RES_SCALE));

    if (!procCanvas || procCanvas.width !== pW || procCanvas.height !== pH){
      if (srcMat) { srcMat.delete(); srcMat = null; }
      if (grayMat) { grayMat.delete(); grayMat = null; }
      procCanvas = document.createElement('canvas'); procCanvas.width = pW; procCanvas.height = pH;
      procCtx = procCanvas.getContext('2d', { willReadFrequently: true });
      srcMat = new cv.Mat(pH, pW, cv.CV_8UC4);
      grayMat = new cv.Mat(pH, pW, cv.CV_8UC1);
      log('Reiniciado procesador: ' + pW + 'x' + pH);
    }

    procCtx.drawImage(cam, 0, 0, pW, pH);
    const imageData = procCtx.getImageData(0,0,pW,pH);
    if (srcMat && srcMat.data && srcMat.data.length === imageData.data.length){
      srcMat.data.set(imageData.data);
    } else {
      srcMat = cv.imread(procCanvas);
    }

    if (frameCounter !== 0){
      requestAnimationFrame(processFrame);
      return;
    }

    cv.cvtColor(srcMat, grayMat, cv.COLOR_RGBA2GRAY);

    let frameKeypoints = new cv.KeyPointVector();
    let frameDescriptors = new cv.Mat();
    try {
      orb.detect(grayMat, frameKeypoints);
      orb.compute(grayMat, frameKeypoints, frameDescriptors);
    } catch(e){
      try {
        orb.detectAndCompute(grayMat, new cv.Mat(), frameKeypoints, frameDescriptors);
      } catch(err){
        console.error('ORB detect/compute error on frame:', err);
        frameKeypoints.delete(); frameDescriptors.delete();
        requestAnimationFrame(processFrame);
        return;
      }
    }

    const tplK = templKeypoints ? templKeypoints.size() : 0;
    const frmK = frameKeypoints ? frameKeypoints.size() : 0;

    if (!tplK || !frmK){
      ctx.clearRect(0,0,overlay.width, overlay.height);
      ctx.fillStyle='white'; ctx.font='16px Arial';
      ctx.fillText('Match: -- (kp tpl:'+tplK+' frm:'+frmK+')',10,20);
      frameKeypoints.delete(); frameDescriptors.delete();
      hideVideoOverlay();
      requestAnimationFrame(processFrame);
      return;
    }

    let matches = new cv.DMatchVectorVector();
    try {
      bf.knnMatch(frameDescriptors, templDescriptors, matches, 2);
    } catch(e){
      try { bf.knnMatch(templDescriptors, frameDescriptors, matches, 2); }
      catch(err){ console.error('BFMatcher.knnMatch failed', err); matches.delete(); frameKeypoints.delete(); frameDescriptors.delete(); requestAnimationFrame(processFrame); return; }
    }

    // ratio test -> plain JS objects
    let goodMatches = [];
    for (let i = 0; i < matches.size(); i++) {
      const mv = matches.get(i);
      if (mv.size() >= 2) {
        const m = mv.get(0);
        const n = mv.get(1);
        if (m.distance <= MATCH_RATIO * n.distance) {
          goodMatches.push({ queryIdx: m.queryIdx, trainIdx: m.trainIdx, distance: m.distance });
        }
      } else if (mv.size() === 1) {
        const m = mv.get(0);
        if (m.distance < 30) { goodMatches.push({ queryIdx: m.queryIdx, trainIdx: m.trainIdx, distance: m.distance }); }
      }
      mv.delete();
    }
    matches.delete();

    if (goodMatches.length < minMatchCount){
      frameKeypoints.delete(); frameDescriptors.delete();
      ctx.clearRect(0,0,overlay.width, overlay.height);
      ctx.fillStyle='white'; ctx.font='16px Arial';
      ctx.fillText('Matches: ' + (goodMatches.length) + ' (need '+minMatchCount+')',10,20);
      bigMatch.textContent = 'Matches: ' + (goodMatches.length);
      hideVideoOverlay();
      requestAnimationFrame(processFrame);
      return;
    }

    // prepare arrays for homography
    const srcPts = [];
    const dstPts = [];
    for (let i=0; i<goodMatches.length; i++){
      const gm = goodMatches[i];
      const queryIdx = gm.queryIdx;
      const trainIdx = gm.trainIdx;
      const kpFrame = frameKeypoints.get(queryIdx);
      const kpTpl = templKeypoints.get(trainIdx);
      srcPts.push(kpFrame.pt.x, kpFrame.pt.y);
      dstPts.push(kpTpl.pt.x, kpTpl.pt.y);
    }

    let srcMatPts = cv.matFromArray(goodMatches.length, 1, cv.CV_32FC2, srcPts);
    let dstMatPts = cv.matFromArray(goodMatches.length, 1, cv.CV_32FC2, dstPts);
    let mask = new cv.Mat();
    let H = cv.findHomography(srcMatPts, dstMatPts, cv.RANSAC, 5.0, mask);

    let inliers = 0;
    for (let i=0; i<mask.rows; i++){
      if (mask.ucharPtr(i,0)[0]) inliers++;
    }

    ctx.clearRect(0,0,overlay.width, overlay.height);
    ctx.fillStyle='white'; ctx.font='16px Arial';
    ctx.fillText('Matches: ' + goodMatches.length + ' inliers:' + inliers,10,20);
    bigMatch.textContent = 'Matches: ' + goodMatches.length + ' | Inliers: ' + inliers;

    if (!H.empty() && inliers >= Math.max(5, Math.floor(goodMatches.length * 0.25))){
      // invert homography -> template -> frame
      let H_inv = new cv.Mat();
      cv.invert(H, H_inv, cv.DECOMP_LU);

      const tw = templGray.cols, th = templGray.rows;
      const tplCorners = cv.matFromArray(4,1,cv.CV_32FC2, [0,0, tw,0, tw,th, 0,th]);
      let dstCorners = new cv.Mat();
      cv.perspectiveTransform(tplCorners, dstCorners, H_inv);

      const scaleX = overlay.width / srcMat.cols;
      const scaleY = overlay.height / srcMat.rows;

      const x0 = dstCorners.floatAt(0,0), y0 = dstCorners.floatAt(0,1);
      const x1 = dstCorners.floatAt(1,0), y1 = dstCorners.floatAt(1,1);
      const x2 = dstCorners.floatAt(2,0), y2 = dstCorners.floatAt(2,1);
      const x3 = dstCorners.floatAt(3,0), y3 = dstCorners.floatAt(3,1);

      const minX = Math.min(x0,x1,x2,x3), maxX = Math.max(x0,x1,x2,x3);
      const minY = Math.min(y0,y1,y2,y3), maxY = Math.max(y0,y1,y2,y3);
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;
      const drawW = (maxX - minX) * scaleX;
      const drawH = (maxY - minY) * scaleY;
      const drawCX = centerX * scaleX;
      const drawCY = centerY * scaleY;

      // compute angle from corner0 -> corner1 (in frame coordinates)
      const angleRad = Math.atan2(y1 - y0, x1 - x0);
      const angleDeg = angleRad * 180 / Math.PI;

      // debug polygon
      ctx.strokeStyle = 'rgba(0,255,150,0.95)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(x0*scaleX, y0*scaleY);
      ctx.lineTo(x1*scaleX, y1*scaleY);
      ctx.lineTo(x2*scaleX, y2*scaleY);
      ctx.lineTo(x3*scaleX, y3*scaleY);
      ctx.closePath();
      ctx.stroke();

      // show video overlay centered and rotated
      showVideoOverlayCentered(drawCX, drawCY, drawW, drawH, angleDeg);

      tplCorners.delete(); dstCorners.delete(); H_inv.delete();
    } else {
      hideVideoOverlay();
    }

    // cleanup
    srcMatPts.delete(); dstMatPts.delete(); mask.delete();
    if (H && !H.isDeleted) H.delete();
    frameKeypoints.delete(); frameDescriptors.delete();

  } catch(err){
    console.error('Error procesando frame (ORB):', err);
  } finally {
    requestAnimationFrame(processFrame);
  }
}

/* start */
startBtn.addEventListener('click', async ()=>{
  startBtn.disabled = true;
  startBtn.style.display = 'none';
  log('Activando cámara...');
  await startCamera();
});

/* cleanup */
window.addEventListener('pagehide', ()=>{
  try {
    if (srcMat) { srcMat.delete(); srcMat = null; }
    if (grayMat) { grayMat.delete(); grayMat = null; }
    if (templMat) { templMat.delete(); templMat = null; }
    if (templGray) { templGray.delete(); templGray = null; }
    if (templKeypoints) { templKeypoints.delete(); templKeypoints = null; }
    if (templDescriptors) { templDescriptors.delete(); templDescriptors = null; }
  } catch(e){}
  stopCamera();
});
</script>
</body>
</html>
