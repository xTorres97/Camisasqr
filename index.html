<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>AR Debug - index</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    html,body{margin:0;height:100%;background:#000;color:#fff;font-family:Arial, sans-serif}
    #videoWrapper{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;overflow:hidden}
    video#cam{width:100%;height:100%;object-fit:cover;}
    canvas#overlay{position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none; z-index:20}
    #overlayContainer{position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); pointer-events:none; z-index:9999; display:none}
    #controls{position:fixed; right:12px; top:60px; z-index:10000; display:flex; flex-direction:column; gap:8px}
    .ctrlBtn{padding:8px 10px;border-radius:6px;border:none;background:#ff4fa8;color:#fff;font-weight:600}
    #log{position:fixed;left:8px;top:8px;background:rgba(0,0,0,0.6);padding:6px 8px;border-radius:6px;font-size:12px;z-index:40;max-width:70vw;white-space:pre-wrap}
    #bigMatch{position:fixed;left:8px;top:80px;font-size:16px;font-weight:700;color:#fff;text-shadow:0 0 6px #000;z-index:40}
  </style>
</head>
<body>
  <div id="videoWrapper">
    <video id="cam" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>
  <div id="overlayContainer"></div>

  <div id="controls">
    <button id="startBtn" class="ctrlBtn">Activar AR</button>
    <button id="testShow" class="ctrlBtn">Mostrar animación de prueba</button>
    <button id="relax" class="ctrlBtn">Relajar thresholds</button>
  </div>

  <div id="log">log:</div>
  <div id="bigMatch">Match: --</div>

<script>
/* CONFIG de debugging */
const TARGET_URL = './medusa.png';   // ya lo pusiste en repo
const ANIM_URL = './medusa.webm';    // animación en repo (asegúrate path correcto)

/* PERFORMANCE / THRESH */
let RES_SCALE = 0.85;      // aumentar para más detalles
let FRAME_SKIP = 1;        // procesar cada frame durante debug
let REQUIRED_MATCHES = 6;
let REQUIRED_INLIERS = 4;
let CENTROID_THRESHOLD = 0.25;

/* worker comms */
const cam = document.getElementById('cam');
const overlay = document.getElementById('overlay');
const logEl = document.getElementById('log');
const bigMatch = document.getElementById('bigMatch');
const overlayContainer = document.getElementById('overlayContainer');
const startBtn = document.getElementById('startBtn');
const testShow = document.getElementById('testShow');
const relaxBtn = document.getElementById('relax');

let worker = null;
let streaming = false;
let procW = 1, procH = 1;
let offscreen = null;
let frameCounter = 0;
let templW = 0, templH = 0;

function L(s){ logEl.textContent = 'log:\n' + s + '\n' + logEl.textContent; console.log(s); }
L('iniciando...');

startBtn.addEventListener('click', async ()=>{
  startBtn.disabled = true; await startCamera();
});
testShow.addEventListener('click', ()=> {
  // show overlay quickly for debug
  overlayContainer.innerHTML = `<video id="fx" autoplay loop muted playsinline style="width:300px;height:300px;object-fit:contain;"><source src="${ANIM_URL}" type="video/webm"></video>`;
  overlayContainer.style.display = 'block';
});
relaxBtn.addEventListener('click', ()=>{
  // relajar umbrales en runtime
  REQUIRED_MATCHES = 4; REQUIRED_INLIERS = 3; CENTROID_THRESHOLD = 0.4; RES_SCALE = 0.9;
  L('Thresholds relajados: REQUIRED_MATCHES=4 REQUIRED_INLIERS=3 CENTROID_THRESHOLD=0.4 RES_SCALE=0.9');
});

async function startCamera(){
  try {
    const s = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
    cam.srcObject = s;
    await cam.play();
    streaming = true;
    resize();
    initWorker();
    scheduleFrames();
    L('Cámara activa.');
  } catch(e){ alert('Error al abrir cámara: '+e.message); L('Error startCamera: '+e.message); }
}

function resize(){
  overlay.width = cam.videoWidth; overlay.height = cam.videoHeight;
  overlay.style.width = cam.clientWidth + 'px'; overlay.style.height = cam.clientHeight + 'px';
  procW = Math.max(1, Math.floor(cam.videoWidth * RES_SCALE));
  procH = Math.max(1, Math.floor(cam.videoHeight * RES_SCALE));
  try { offscreen = new OffscreenCanvas(procW, procH); } catch(e){ const c = document.createElement('canvas'); c.width = procW; c.height = procH; offscreen = c; }
  L(`resize: cam ${cam.videoWidth}x${cam.videoHeight} proc ${procW}x${procH}`);
}

/* Worker init */
function initWorker(){
  if (worker){ worker.terminate(); worker = null; }
  worker = new Worker('worker.js');
  worker.onmessage = (ev)=>{
    const d = ev.data;
    if (d.type === 'ready'){ L('worker ready'); worker.postMessage({type:'init', targetUrl: TARGET_URL, procW, procH}); }
    else if (d.type === 'log'){ L('worker: '+d.msg); }
    else if (d.type === 'templateInfo'){ templW=d.w; templH=d.h; L(`templ info: ${templW}x${templH}`); }
    else if (d.type === 'result'){ handleResult(d); }
    else if (d.type === 'error'){ L('worker error: '+d.msg); }
  };
}

/* draw overlay centered fixed (no rotation) */
function showOverlayCenteredFixed(sizePx){
  overlayContainer.innerHTML = `<video id="fx" autoplay loop muted playsinline style="width:${sizePx}px;height:${sizePx}px;object-fit:cover;"><source src="${ANIM_URL}" type="video/webm"></video>`;
  overlayContainer.style.display = 'block';
}
function hideOverlay(){ overlayContainer.style.display='none'; overlayContainer.innerHTML=''; }

/* handle worker result (debug) */
function handleResult(d){
  bigMatch.textContent = `Matches: ${d.matches} | Inliers: ${d.inliers}`;
  // log everything so we can inspect
  if (d.debug) L('worker debug: ' + d.debug);
  if (!d.corners || d.matches < REQUIRED_MATCHES || d.inliers < REQUIRED_INLIERS){
    hideOverlay();
    return;
  }
  // map centroid using video DOM rect to avoid object-fit crops
  const vRect = cam.getBoundingClientRect();
  const scaleX = vRect.width / cam.videoWidth;
  const scaleY = vRect.height / cam.videoHeight;
  const left = vRect.left + window.scrollX;
  const top = vRect.top + window.scrollY;
  const cx_proc = (d.corners[0]+d.corners[2]+d.corners[4]+d.corners[6]) / 4;
  const cy_proc = (d.corners[1]+d.corners[3]+d.corners[5]+d.corners[7]) / 4;
  const cx_screen = left + cx_proc * scaleX;
  const cy_screen = top + cy_proc * scaleY;
  const screenCenterX = window.scrollX + (window.innerWidth/2);
  const screenCenterY = window.scrollY + (window.innerHeight/2);
  const dx = cx_screen - screenCenterX, dy = cy_screen - screenCenterY;
  const diag = Math.hypot(window.innerWidth, window.innerHeight);
  const distNorm = Math.hypot(dx,dy) / diag;
  L(`centroid distNorm=${distNorm.toFixed(3)} cx_screen=${cx_screen.toFixed(1)} cy_screen=${cy_screen.toFixed(1)}`);
  if (distNorm > CENTROID_THRESHOLD){ hideOverlay(); return; }
  // show centered overlay
  const sizePx = Math.round(Math.min(window.innerWidth*0.6, window.innerHeight*0.6));
  showOverlayCenteredFixed(sizePx);
}

/* send frame to worker */
async function sendFrame(){
  if (!streaming || !worker) return;
  // keep sizes in sync
  const newW = Math.max(1, Math.floor(cam.videoWidth * RES_SCALE));
  const newH = Math.max(1, Math.floor(cam.videoHeight * RES_SCALE));
  if (newW !== procW || newH !== procH){ procW = newW; procH = newH; resize(); worker.postMessage({type:'resize', procW, procH}); L('updated proc size'); }
  const ctx = offscreen.getContext('2d');
  ctx.drawImage(cam, 0, 0, procW, procH);
  let bitmap;
  try {
    if (offscreen.transferToImageBitmap) bitmap = offscreen.transferToImageBitmap();
    else {
      const blob = await new Promise(r=> offscreen.toBlob(r,'image/png'));
      bitmap = await createImageBitmap(blob);
    }
    worker.postMessage({type:'frame', bitmap: bitmap}, [bitmap]);
  } catch(e){ L('sendFrame error: '+e.message); }
}

/* frame loop */
function scheduleFrames(){
  frameCounter = 0;
  function loop(){
    frameCounter = (frameCounter+1) % FRAME_SKIP;
    if (frameCounter === 0) sendFrame();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
}

</script>
</body>
</html>
