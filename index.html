<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>AR Camiseta - OpenCV Template Matching (Optimizado)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <style>
    html,body{margin:0;height:100%;background:#000;color:#fff;font-family:Arial, sans-serif}
    #videoWrapper{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;overflow:hidden}
    video#cam{width:100%;height:100%;object-fit:cover;transform:scaleX(-1);} /* espejo para UX */
    canvas#overlay{position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none}
    #startBtn{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);padding:14px 18px;background:#ff4fa8;border-radius:10px;border:none;color:#fff;font-size:18px;z-index:30}
    #note{position:fixed;left:0;right:0;bottom:10px;text-align:center;z-index:30;opacity:0.9}
    #log{position:fixed;left:8px;top:8px;background:rgba(0,0,0,0.6);padding:6px 8px;border-radius:6px;font-size:12px;z-index:30}
  </style>
</head>
<body>
  <div id="videoWrapper">
    <video id="cam" autoplay playsinline></video>
    <canvas id="overlay"></canvas>
  </div>

  <button id="startBtn">Activar AR</button>
  <div id="note">Apunta la cámara hacia la imagen de la camiseta</div>
  <div id="log">listo</div>

  <!-- OpenCV.js (CDN) -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="console.log('OpenCV cargado')"></script>

<script>
/* ---------------- CONFIG ---------------- */
const TARGET_URL = './target.png';   // Debe existir en la misma carpeta
let MATCH_THRESHOLD = 0.60;         // Ajusta entre 0.55 - 0.80 según pruebas
const RES_SCALE = 0.8;              // Procesar a 50% para mejor rendimiento
/* ---------------------------------------- */

const cam = document.getElementById('cam');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');
const startBtn = document.getElementById('startBtn');
const logEl = document.getElementById('log');

let videoStream = null;
let streaming = false;

// OpenCV mats
let srcMat = null, grayMat = null, templMat = null, templGray = null, resMat = null;
let procCanvas = null, procCtx = null;
let animStart = null;

function log(s){ logEl.textContent = s; console.log(s); }

/* ---------- Animación corazón (canvas) ---------- */
function drawHeart(x, y, w, h, t){
  // x,y in canvas coords (center)
  const maxR = Math.min(w,h) * 0.5;
  const pulse = 0.85 + 0.25 * Math.sin(t/200);
  const r = maxR * pulse;

  // glow
  ctx.save();
  const grad = ctx.createRadialGradient(x, y, r*0.1, x, y, r*1.3);
  grad.addColorStop(0, 'rgba(255,122,200,0.95)');
  grad.addColorStop(0.5, 'rgba(255,122,200,0.45)');
  grad.addColorStop(1, 'rgba(255,122,200,0.0)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(x, y, r*1.4, 0, Math.PI*2);
  ctx.fill();

  // heart path scaled
  ctx.translate(x, y);
  ctx.scale(r/50, r/50);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.bezierCurveTo(0, -25, -50, -25, -50, 0);
  ctx.bezierCurveTo(-50, 30, -20, 55, 0, 75);
  ctx.bezierCurveTo(20, 55, 50, 30, 50, 0);
  ctx.bezierCurveTo(50, -25, 0, -25, 0, 0);
  ctx.closePath();
  ctx.fillStyle = 'rgba(255,120,200,0.95)';
  ctx.fill();
  ctx.restore();
}

/* ---------- Cámara ---------- */
async function startCamera(){
  try {
    videoStream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
    cam.srcObject = videoStream;
    await cam.play();
    streaming = true;
    resizeCanvas();
    prepareOpenCV();
  } catch(e){
    alert('Error al abrir la cámara: ' + e.message);
    console.error(e);
  }
}

function stopCamera(){
  if (videoStream) {
    videoStream.getTracks().forEach(t => t.stop());
    streaming = false;
  }
}

function resizeCanvas(){
  overlay.width = cam.videoWidth;
  overlay.height = cam.videoHeight;
  overlay.style.width = cam.clientWidth + 'px';
  overlay.style.height = cam.clientHeight + 'px';
}

/* ---------- Preparar OpenCV y template ---------- */
async function prepareOpenCV(){
  log('Esperando OpenCV...');
  if (typeof cv === 'undefined' || !cv.imread){
    let waited=0;
    while((typeof cv === 'undefined' || !cv.imread) && waited < 5000){
      await new Promise(r=>setTimeout(r,100));
      waited += 100;
    }
  }
  if (typeof cv === 'undefined' || !cv.imread){
    alert('OpenCV no se cargó. Recarga la página.');
    return;
  }

  log('OpenCV listo — cargando template...');
  const img = new Image();
  img.crossOrigin = "anonymous";
  img.src = TARGET_URL + '?v=' + Date.now();
  img.onload = () => {
    // crear canvas temporal para leer template
    const tmp = document.createElement('canvas');
    tmp.width = img.width; tmp.height = img.height;
    const tctx = tmp.getContext('2d');
    tctx.drawImage(img, 0, 0);
    if (templMat) { templMat.delete(); templMat = null; }
    if (templGray) { templGray.delete(); templGray = null; }

    templMat = cv.imread(tmp);
    templGray = new cv.Mat();
    cv.cvtColor(templMat, templGray, cv.COLOR_RGBA2GRAY);

    // preparar canvas de procesamiento reducido
    const procCanvasW = Math.max(1, Math.floor(cam.videoWidth * RES_SCALE));
    const procCanvasH = Math.max(1, Math.floor(cam.videoHeight * RES_SCALE));
    procCanvas = document.createElement('canvas');
    procCanvas.width = procCanvasW;
    procCanvas.height = procCanvasH;
    // willReadFrequently para acelerar getImageData en algunos navegadores
    procCtx = procCanvas.getContext('2d', { willReadFrequently: true });

    // Mats reducidos (crearlos una vez)
    if (srcMat) { srcMat.delete(); srcMat = null; }
    if (grayMat) { grayMat.delete(); grayMat = null; }
    if (resMat) { resMat.delete(); resMat = null; }

    srcMat = new cv.Mat(procCanvasH, procCanvasW, cv.CV_8UC4);
    grayMat = new cv.Mat(procCanvasH, procCanvasW, cv.CV_8UC1);

    // crear resMat si cabe
    const resW = procCanvasW - templGray.cols + 1;
    const resH = procCanvasH - templGray.rows + 1;
    if (resW > 0 && resH > 0) {
      resMat = new cv.Mat(resH, resW, cv.CV_32FC1);
      log('Template cargado: ' + templMat.cols + 'x' + templMat.rows + ' — procesando a ' + procCanvasW + 'x' + procCanvasH);
    } else {
      resMat = null;
      log('AVISO: el template (' + templGray.cols + 'x' + templGray.rows + ') es mayor que la zona de procesamiento (' + procCanvasW + 'x' + procCanvasH + '). Aumenta RES_SCALE o recorta target.png');
    }

    animStart = performance.now();
    requestAnimationFrame(processFrame);
  };
  img.onerror = (e) => {
    alert('No se pudo cargar target.png desde: ' + TARGET_URL);
    console.error(e);
  };
}

/* ---------- Procesamiento por frame (optimizado) ---------- */
function processFrame(now){
  if (!streaming) return;
  try {
    // Si el tamaño del video cambió, reajustar canvas y mats
    const neededW = Math.max(1, Math.floor(cam.videoWidth * RES_SCALE));
    const neededH = Math.max(1, Math.floor(cam.videoHeight * RES_SCALE));
    if (!procCanvas || procCanvas.width !== neededW || procCanvas.height !== neededH) {
      // liberar mats viejos
      if (srcMat) { srcMat.delete(); srcMat = null; }
      if (grayMat) { grayMat.delete(); grayMat = null; }
      if (resMat) { resMat.delete(); resMat = null; }

      // recrear procCanvas y mats
      procCanvas = document.createElement('canvas');
      procCanvas.width = neededW;
      procCanvas.height = neededH;
      procCtx = procCanvas.getContext('2d', { willReadFrequently: true });

      srcMat = new cv.Mat(neededH, neededW, cv.CV_8UC4);
      grayMat = new cv.Mat(neededH, neededW, cv.CV_8UC1);

      const resW = neededW - (templGray ? templGray.cols : 0) + 1;
      const resH = neededH - (templGray ? templGray.rows : 0) + 1;
      if (resW > 0 && resH > 0) {
        resMat = new cv.Mat(resH, resW, cv.CV_32FC1);
      } else {
        resMat = null;
      }
      log('Reinicializado procesador: ' + neededW + 'x' + neededH + ' (resMat ' + (resMat ? 'ok' : 'INVALID') + ')');
    }

    // Dibujar video reducido en procCanvas
    procCtx.drawImage(cam, 0, 0, procCanvas.width, procCanvas.height);

    // actualizar srcMat sin crear nuevos objetos (más eficiente)
    const imageData = procCtx.getImageData(0, 0, procCanvas.width, procCanvas.height);
    if (srcMat && srcMat.data && srcMat.data.length === imageData.data.length) {
      srcMat.data.set(imageData.data);
    } else {
      // fallback seguro
      srcMat = cv.imread(procCanvas);
    }

    // convertir a gris
    cv.cvtColor(srcMat, grayMat, cv.COLOR_RGBA2GRAY);

    // solo ejecutar matchTemplate si resMat es válido
    if (!resMat || resMat.rows <= 0 || resMat.cols <= 0) {
      // no podemos calcular: template demasiado grande o resMat inválida
      ctx.clearRect(0,0,overlay.width, overlay.height);
      ctx.fillStyle = 'white'; ctx.font = '14px Arial';
      ctx.fillText('Template too large for processing area. Increase RES_SCALE or use a smaller template.', 10, 24);
      requestAnimationFrame(processFrame);
      return;
    }

    // matchTemplate y minMaxLoc (seguro ahora)
    cv.matchTemplate(grayMat, templGray, resMat, cv.TM_CCOEFF_NORMED);
    let minVal = {value:0}, maxVal = {value:0}, minLoc = {x:0,y:0}, maxLoc = {x:0,y:0};
    cv.minMaxLoc(resMat, minVal, maxVal, minLoc, maxLoc);
    const best = maxVal.value;

    // limpiar overlay y dibujar info
    ctx.clearRect(0,0,overlay.width, overlay.height);
    ctx.fillStyle = 'white'; ctx.font = '16px Arial';
    ctx.fillText('Match: ' + best.toFixed(3), 10, 20);

    if (best >= MATCH_THRESHOLD) {
      const scaleX = overlay.width / procCanvas.width;
      const scaleY = overlay.height / procCanvas.height;

      const matchX = maxLoc.x + templGray.cols/2;
      const matchY = maxLoc.y + templGray.rows/2;

      const drawX = overlay.width - (matchX * scaleX); // mirror
      const drawY = matchY * scaleY;
      const drawW = templGray.cols * scaleX;
      const drawH = templGray.rows * scaleY;

      ctx.strokeStyle = 'rgba(255,120,200,0.9)';
      ctx.lineWidth = 4;
      ctx.strokeRect(overlay.width - ((maxLoc.x + templGray.cols) * scaleX), maxLoc.y * scaleY, drawW, drawH);

      const elapsed = now - animStart;
      drawHeart(drawX, drawY, drawW, drawH, elapsed);
    }

  } catch(err) {
    console.error('Error en procesamiento frame (guardado):', err);
  } finally {
    requestAnimationFrame(processFrame);
  }
}
/* ---------- Evento del botón ---------- */
startBtn.addEventListener('click', async () => {
  startBtn.disabled = true;
  startBtn.style.display = 'none';
  log('Activando cámara...');
  await startCamera();
});

/* ---------- Limpieza al cerrar ---------- */
window.addEventListener('pagehide', () => {
  try {
    if (srcMat) { srcMat.delete(); srcMat = null; }
    if (grayMat) { grayMat.delete(); grayMat = null; }
    if (templMat) { templMat.delete(); templMat = null; }
    if (templGray) { templGray.delete(); templGray = null; }
    if (resMat) { resMat.delete(); resMat = null; }
  } catch(e){}
  stopCamera();
});

/* ---------- Tips rápidos ---------- */
/*
 - Si la detección es muy estricta, baja MATCH_THRESHOLD a 0.60 o 0.55.
 - Si la detección es muy lenta, reduce RES_SCALE (por ejemplo 0.4) o recorta target.png para que sea más pequeño.
 - Si necesitas tolerancia a rotación/escala muy grande, considera la versión ORB/feature-matching (yo puedo implementarla).
*/

</script>
</body>
</html>
